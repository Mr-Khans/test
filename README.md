
# Синтезатор Текстур на Python с GPU-ускорением

Этот проект представляет собой реализацию алгоритма синтеза текстур на Python, который позволяет создавать большие бесшовные изображения из одного небольшого образца текстуры. Алгоритм основан на методе "Image Quilting" и оптимизирован для быстрых вычислений на GPU с использованием библиотеки CuPy.

# Демонстрация работы

| Исходная текстура                         | Результат синтеза (3x3)                                  |
| ----------------------------------------- | -------------------------------------------------------- |
| <img src="input/texture.png" width="500"> | <img src="examples/texture_synthesized.jpg" width="500"> |


# Ключевые возможности
Бесшовное сшивание: Использование алгоритма поиска пути минимальной стоимости (Seam Carving) для создания невидимых швов между фрагментами.

Устранение повторений: Внедрен механизм случайного выбора из нескольких лучших кандидатов, что предотвращает появление заметных повторяющихся паттернов.

Высокая производительность: Основные вычисления (расчет SSD) перенесены на GPU с помощью CuPy, что значительно ускоряет процесс.

Гибкая работа: Код автоматически определяет наличие GPU и, в случае его отсутствия, переключается на NumPy (CPU), что делает его универсальным.

Простота использования: Скрипт легко настроить, изменив всего несколько параметров: путь к файлу, размер патча и степень их наложения.

# Технический стек
Python 3.x

OpenCV — для чтения и записи изображений.

NumPy — для базовых вычислений на CPU.

CuPy — для высокопроизводительных вычислений на GPU NVIDIA.

Tqdm — для наглядного отображения прогресса.


# Отчет о выполнении

## 1. Использованные методы
Для решения задачи был реализован алгоритм синтеза текстур, основанный на классической работе "Image Quilting for Texture Synthesis and Transfer". Основная идея заключается в "сшивании" небольших фрагментов (патчей) исходной текстуры для создания нового, большего изображения.

Поиск кандидатов: Сходство патчей определяется с помощью метрики SSD (Sum of Squared Differences).

Минимизация повторений: Чтобы избежать монотонности, из нескольких лучших кандидатов выбирается один случайным образом.

Сшивание по шву минимальной стоимости (Seam Carving): Для создания невидимых стыков используется динамическое программирование для поиска пути с минимальной ошибкой в зоне наложения.

Оптимизация с помощью GPU: Наиболее затратная часть — расчет SSD — была перенесена на GPU с использованием библиотеки CuPy.

## 2. Возникшие проблемы и узкие места
Производительность: Главной проблемой была и остается производительность. Несмотря на перенос вычислений SSD на GPU, алгоритм по своей природе является итеративным.

"Бутылочное горлышко" при поиске шва: Алгоритм поиска пути минимальной стоимости (Seam Carving) по своей сути последовательный и плохо поддается распараллеливанию. В текущей реализации он выполняется на CPU, что создает задержки из-за копирования данных между CPU и GPU.

## 3. Плюсы и минусы решения

### Плюсы:

Высокое качество результата: Отсутствие видимых швов и повторений.

Гибкость: Код легко адаптировать под разные параметры.

Оптимизация: Использование GPU (CuPy) значительно ускоряет процесс.

Надежность: Код автоматически переключается между GPU и CPU.

### Минусы:

Требовательность к ресурсам: Для больших изображений требуется значительный объем видеопамяти и вычислительного времени.

Узкое место на CPU: Пересылка данных между CPU и GPU для поиска шва замедляет общую производительность.

## 4. Затраченное время
На выполнение задания, включая изучение алгоритма, написание кода и отладку, было потрачено около 5-6 часов.


<p>This code was developed by <a href="https://www.linkedin.com/in/alexey-hanevski-6a0b2b138/" target="_new">Alexey Khaneuski</a>.</p>